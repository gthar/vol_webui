#!{{ interpreter }}

"""
Server part of the app. Communicate with the client through WebSockets
"""

import argparse
import asyncio
import functools
import json
import sys

import alsaaudio
import websockets


# These two will be hardcoded resulting file. This allows me to have
# the client javascript sent as a static file
PREFIX = {{ prefix }}
PORT = {{ port }}


def query_mixer(mixer_name):
    """
    Query the current state of the mixer
    input: mixer_name
    output: a tuple with the volume (0-100) and the mute state (0/1)
    """
    mixer = alsaaudio.Mixer(mixer_name)
    vol, _ = mixer.getvolume()
    mute, _ = mixer.getmute()
    return vol, mute


async def broadcast(connected, msg):
    """
    Given a list of connected clients and a message, send the message to all
    of them
    """
    for socket in connected:
        await socket.send(msg)


def mk_msg(val_type, value):
    """
    Given a type of message (vol/mute) and its value, create a JSON message
    for it
    """
    return json.dumps({'type': val_type, 'value': value})


def parse_monitor_out(line):
    """
    Parse one line of the monitorer output
    """
    param, val = line.split()
    return param, int(val)


def vol_scaler(state):
    """
    Scale the volume to the range 0-100
    """
    range = state["pmax"] - state["pmin"]
    scaled = (state["vol"] - state["pmin"]) / range * 100
    return int(scaled)


async def producer(card, device, mixer, connected):
    """
    Given a mixer, a card and a list of connected clients, watch for changes in
    volume and mute state and broadcast any changes to all clients
    """
    global state

    print("starting monitor loop")
    cmd = PREFIX + "/bin/alsa_events"

    proc = await asyncio.create_subprocess_exec(
        cmd, card, device, mixer,
        stdout=asyncio.subprocess.PIPE
    )

    # read and store the initial values
    delim = '----\n'
    content = await proc.stdout.readuntil(delim.encode())
    lines = content.decode().replace(delim, "").strip().split("\n")
    state = dict(parse_monitor_out(line) for line in lines)

    async for line in proc.stdout:

        try:
            param, val = parse_monitor_out(line.decode())
        except:
            continue

        state[param] = val

        if param == "vol":
            vol = vol_scaler(state)
            print("vol changed to {} ({})".format(state["vol"], vol))
            await broadcast(connected, mk_msg('volume', vol))

        if param == "on":
            mute = not state["on"]
            print("on changed to {} (mute={})".format(state["on"], mute))
            await broadcast(connected, mk_msg('mute', mute))

    returncode = await proc.wait()
    return returncode


async def handler(websocket, _, connected, mixer_name):
    """
    WebSocket handler. Watch for changes in the clients and update the volume
    accordingly
    """
    global state
    connected.add(websocket)
    try:
        vol = vol_scaler(state)
        mute = not state["on"]
        #vol, mute = query_mixer(mixer_name)
        await websocket.send(mk_msg('volume', vol))
        await websocket.send(mk_msg('mute', mute))

        async for msg in websocket:
            data = json.loads(msg)
            mixer = alsaaudio.Mixer(mixer_name)

            if data['type'] == 'volume':
                mixer.setvolume(data['value'])

            elif data['type'] == 'mute':
                mute, _ = mixer.getmute()
                mixer.setmute(not mute)

            else:
                print("unsupported event: {}", data)

    finally:
        connected.remove(websocket)


def main():
    """
    Parse the arguments and start the server
    """

    parser = argparse.ArgumentParser(description="Volume Web UI")
    parser.add_argument("--host", type=str, default='localhost')
    parser.add_argument("--card", type=str, default='hw:0')
    parser.add_argument("--device", type=str, default='default')
    parser.add_argument("--mixer", type=str, default='Master')
    args = parser.parse_args()

    connected = set()
    state = {}
    loop = asyncio.get_event_loop()
    loop.create_task(producer(
        args.card,
        args.device,
        args.mixer,
        connected))
    loop.run_until_complete(websockets.serve(
        functools.partial(
            handler,
            connected=connected,
            mixer_name=args.mixer),
        args.host,
        PORT
    ))
    loop.run_forever()


if __name__ == '__main__':
    sys.exit(main())
