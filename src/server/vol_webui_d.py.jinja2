#!{{ interpreter }}

"""
Server part of the app. Communicate with the client through WebSockets
"""

import argparse
import asyncio
import functools
import json
import sys

import websockets


# These two will be hardcoded resulting file. This allows me to have
# the client javascript sent as a static file
PREFIX = {{ prefix }}
PORT = {{ port }}


async def broadcast(connected, msg):
    """
    Given a list of connected clients and a message, send the message to all
    of them
    """
    for socket in connected:
        await socket.send(msg)


def mk_msg(val_type, value):
    """
    Given a type of message (vol/mute) and its value, create a JSON message
    for it
    """
    return json.dumps({'type': val_type, 'value': value})


def parse_monitor_out(line):
    """
    Parse one line of the monitorer output
    """
    param, val = line.split()
    return param, int(val)


def vol_scaler(state):
    """
    Scale the volume to the range 0-100
    """
    range = state["pmax"] - state["pmin"]
    scaled = (state["volume"] - state["pmin"]) / range * 100
    return round(scaled)


def vol_unscaler(vol, state):
    """
    Bring back a value scaled as a percentage to a physical volume
    """
    range = state["pmax"] - state["pmin"]
    scaled = vol / 100 * range + state["pmin"]
    return round(scaled)


async def producer(card, device, mixer, connected):
    """
    Given a mixer, a card and a list of connected clients, watch for changes in
    volume and mute state and broadcast any changes to all clients
    """
    global state

    print("starting monitor loop")
    cmd = PREFIX + "/bin/alsa_events"

    proc = await asyncio.create_subprocess_exec(
        cmd, card, device, mixer,
        stdout=asyncio.subprocess.PIPE
    )

    # read and store the initial values
    delim = '----\n'
    content = await proc.stdout.readuntil(delim.encode())
    lines = content.decode().replace(delim, "").strip().split("\n")
    state = dict(parse_monitor_out(line) for line in lines)

    async for line in proc.stdout:

        try:
            param, val = parse_monitor_out(line.decode())
        except:
            continue

        state[param] = val

        if param == "volume":
            volume = vol_scaler(state)
            print("vol changed to {} ({})".format(state["volume"], volume))
            await broadcast(connected, mk_msg('volume', volume))

        if param == "switch":
            mute = not state["switch"]
            print("switch changed to {} (mute={})".format(state["switch"], mute))
            await broadcast(connected, mk_msg('mute', mute))

    returncode = await proc.wait()
    return returncode


async def set_alsa(param, val, device, mixer):
    """
    Set either the volume or switch state
    """
    cmd = PREFIX + "/bin/alsa_set"
    await asyncio.create_subprocess_exec(
        cmd, device, mixer, param, str(val),
        stdout=asyncio.subprocess.PIPE
    )


async def handler(websocket, _, connected, device, mixer):
    """
    WebSocket handler. Watch for changes in the clients and update the volume
    accordingly
    """
    global state
    connected.add(websocket)
    try:
        volume = vol_scaler(state)
        mute = not state["switch"]
        await websocket.send(mk_msg('volume', volume))
        await websocket.send(mk_msg('mute', mute))

        async for msg in websocket:
            data = json.loads(msg)

            if data['type'] == 'volume':
                vol = vol_unscaler(data['value'], state)
                await set_alsa("volume", vol, device, mixer)

            elif data['type'] == 'mute':
                switch_state = int(not state["switch"])
                await set_alsa("switch", switch_state, device, mixer)

            else:
                print("unsupported event: {}", data)

    finally:
        connected.remove(websocket)


def main():
    """
    Parse the arguments and start the server
    """

    parser = argparse.ArgumentParser(description="Volume Web UI")
    parser.add_argument("--host", type=str, default='localhost')
    parser.add_argument("--card", type=str, default='hw:0')
    parser.add_argument("--device", type=str, default='default')
    parser.add_argument("--mixer", type=str, default='Master')
    args = parser.parse_args()

    connected = set()
    state = {}
    loop = asyncio.get_event_loop()
    loop.create_task(producer(
        args.card,
        args.device,
        args.mixer,
        connected))
    loop.run_until_complete(websockets.serve(
        functools.partial(
            handler,
            connected=connected,
            device=args.device,
            mixer=args.mixer),
        args.host,
        PORT
    ))
    loop.run_forever()


if __name__ == '__main__':
    sys.exit(main())
